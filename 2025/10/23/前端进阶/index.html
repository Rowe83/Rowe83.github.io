<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>前端进阶核心要点 | Rowe's Blog</title><meta name="author" content="Rowe"><meta name="copyright" content="Rowe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前端进阶核心要点 一、JavaScript深度进阶 执行上下文与作用域链：代码是如何运行的   调用栈、全局&#x2F;函数执行上下文，VO&#x2F;AO1234567891011121314151617181920212223242526（1）执行上下文是JavaScript代码执行时的环境，包含代码运行时需要的所有信息，分为全局执行上下文和函数执行上下文（另：eval()函数也会创建一个新的">
<meta property="og:type" content="article">
<meta property="og:title" content="前端进阶核心要点">
<meta property="og:url" content="https://rowe83.github.io/2025/10/23/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="Rowe&#39;s Blog">
<meta property="og:description" content="前端进阶核心要点 一、JavaScript深度进阶 执行上下文与作用域链：代码是如何运行的   调用栈、全局&#x2F;函数执行上下文，VO&#x2F;AO1234567891011121314151617181920212223242526（1）执行上下文是JavaScript代码执行时的环境，包含代码运行时需要的所有信息，分为全局执行上下文和函数执行上下文（另：eval()函数也会创建一个新的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://rowe83.github.io/image/avatar.png">
<meta property="article:published_time" content="2025-10-23T02:10:05.832Z">
<meta property="article:modified_time" content="2025-10-29T08:48:43.374Z">
<meta property="article:author" content="Rowe">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rowe83.github.io/image/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "前端进阶核心要点",
  "url": "https://rowe83.github.io/2025/10/23/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/",
  "image": "https://rowe83.github.io/image/avatar.png",
  "datePublished": "2025-10-23T02:10:05.832Z",
  "dateModified": "2025-10-29T08:48:43.374Z",
  "author": [
    {
      "@type": "Person",
      "name": "Rowe",
      "url": "https://rowe83.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/image/favicon.png"><link rel="canonical" href="https://rowe83.github.io/2025/10/23/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ee1fd8f11e11d61318575315144e1c9a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端进阶核心要点',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/banner2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Rowe's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">前端进阶核心要点</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">前端进阶核心要点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-10-23T02:10:05.832Z" title="Created 2025-10-23 10:10:05">2025-10-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-29T08:48:43.374Z" title="Updated 2025-10-29 16:48:43">2025-10-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/web%E5%89%8D%E7%AB%AF/">web前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="前端进阶核心要点"><a href="#前端进阶核心要点" class="headerlink" title="前端进阶核心要点"></a><strong>前端进阶核心要点</strong></h3><hr>
<h2 id="一、JavaScript深度进阶"><a href="#一、JavaScript深度进阶" class="headerlink" title="一、JavaScript深度进阶"></a>一、JavaScript深度进阶</h2><ol>
<li>执行上下文与作用域链：代码是如何运行的</li>
</ol>
<ul>
<li>调用栈、全局&#x2F;函数执行上下文，VO&#x2F;AO<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">（1）执行上下文是JavaScript代码执行时的环境，包含代码运行时需要的所有信息，分为全局执行上下文和函数执行上下文（另：eval()函数也会创建一个新的执行上下文）；</span><br><span class="line">（2）它有三个核心组成部分：</span><br><span class="line">变量对象（Virable Object：VO）：</span><br><span class="line">    全局上下文：GlobalObject（浏览器中为window）</span><br><span class="line">    函数上下文：Activation Object（AO），包含函数参数、局部变量、函数声明</span><br><span class="line">作用域链：用于解析变量的引用链</span><br><span class="line">this绑定：确定当前代码的执行主体（比如window或对象）</span><br><span class="line">（3）它有三个生命周期：</span><br><span class="line">创建阶段：</span><br><span class="line">    初始化变量对象（变量声明提升、函数声明提升）</span><br><span class="line">    创建作用域链</span><br><span class="line">    绑定this值</span><br><span class="line">执行阶段：</span><br><span class="line">    变量赋值，执行代码逻辑</span><br><span class="line">销毁阶段：</span><br><span class="line">    上下文出栈，释放内存（垃圾回收）</span><br><span class="line">（4）作用域链：JavaScript用于解析变量对象的有序列表，包含当前执行上下文的变量对象以及所有父级上下文的变量对象，作用域链决定了变量的查找顺序</span><br><span class="line">作用域类型：</span><br><span class="line">    全局作用域：全局变量，存在于整个程序生命周期</span><br><span class="line">    函数作用域：函数内部定义的变量，仅在函数内部有效</span><br><span class="line">    块级作用域（ES6+）：let和const声明的变量，限制在&#123;&#125;内</span><br><span class="line">作用域创建：</span><br><span class="line">    函数定义时，[[scoped]]属性记录了包含它的上下文的作用域链，也就是记录父级上下文作用域链</span><br><span class="line">    函数执行时，把当前的变量对象添加到作用域链前端</span><br><span class="line">闭包和作用域链：</span><br><span class="line">    闭包就是在当前作用域中可以访问父级作用域中的变量，即使外部函数已经执行完毕</span><br></pre></td></tr></table></figure></li>
<li>词法作用域 vs 动态作用域，以及this指向的终极解决方案<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">（1）词法作用域</span><br><span class="line">定义：变量的作用域在代码定义时确定，基于代码的物理结构（词法环境）</span><br><span class="line">特点：</span><br><span class="line">    JavaScript语言使用的就是词法作用域</span><br><span class="line">    函数的作用域链在定义时就确定了，指向它的父级作用域</span><br><span class="line">    支持闭包，变量引用外部作用域</span><br><span class="line">（2）动态作用域</span><br><span class="line">定义：变量的作用域在代码执行时确定，基于调用栈</span><br><span class="line">特点：</span><br><span class="line">    JavaScript不使用动态作用域（少数语言使用比如Bash）</span><br><span class="line">    变量查找取决于调用者的上下文，不取决其定义位置</span><br><span class="line">（3）this</span><br><span class="line">定义：this是JavaScript中的特殊关键字，指向当前代码执行的上下文对象，它的值取决于函数的调用方式</span><br><span class="line">this指向：</span><br><span class="line">    默认绑定：函数直接调用，this指向全局对象，浏览器中为window（非严格模式，严格模式下为undefined），Node.js中为global</span><br><span class="line">    对象方法调用：this指向调用方法的对象</span><br><span class="line">    构造函数调用：this指向新创建的实例</span><br><span class="line">    箭头函数：箭头函数本身没有this绑定，它的this指向定义时的词法作用域（外层作用域），不受调用方式影响</span><br><span class="line">    显示绑定（call、apply、bind）：</span><br><span class="line">        call和apply都是直接调用函数，this指向显示指定的函数，这两者只有传参的区别，call方法的参数是队列，apply的参数是数组；</span><br><span class="line">        bind方法返回一个新创建的函数，需要手动调用，this指向新创建的函数</span><br><span class="line">    事件监听：this一般指向触发事件的dom元素</span><br><span class="line">this指向的解决方案：</span><br><span class="line">    为避免this指向的复杂性，优先推荐：</span><br><span class="line">        ①箭头函数</span><br><span class="line">        ②call、apply、bind显示绑定</span><br><span class="line">        ③函数式编程：通过参数传递上下文</span><br><span class="line">    另：vue3中的组合式API使用ref/reactive，无需this</span><br></pre></td></tr></table></figure></li>
<li>闭包的原理、应用场景与内存泄漏风险<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">（1）闭包的定义：闭包是一个函数及其词法作用域的组合，允许函数访问其定义时外部作用域的变量，即使函数已经执行完毕。</span><br><span class="line">（2）闭包的原理：</span><br><span class="line">    JavaScript使用词法作用域，函数定义时其[[Scope]]属性记录了外部作用域的变量对象</span><br><span class="line">    函数执行时创建执行上下文，其作用域链包含自身AO和外部作用域的VO</span><br><span class="line">    闭包就是通过作用域链保留对外部变量的引用，变量不会被垃圾回收</span><br><span class="line">（3）闭包的应用场景：</span><br><span class="line">    ①数据封装：隐藏私有变量，模拟私有属性</span><br><span class="line">    ②状态管理：保留组件状态</span><br><span class="line">    ③事件处理：保留事件处理的状态</span><br><span class="line">    ④异步回调：在异步操作中（如API调用）保留上下文</span><br><span class="line">    ⑤高阶函数的应用：函数节流和防抖依赖闭包来保留定时器ID和时间戳状态</span><br><span class="line">（4）内存泄漏风险：</span><br><span class="line">    原因：闭包保留对外部作用域变量的引用，导致变量无法被垃圾回收，可能造成内存泄漏</span><br><span class="line">    常见场景：</span><br><span class="line">        未释放的闭包引用：事件监听器未清除，保留对闭包的引用</span><br><span class="line">        大型数据结构：闭包引用大对象，占用内存</span><br><span class="line">    解决方案：</span><br><span class="line">        手动释放引用：移除事件监听器，变量置空</span><br><span class="line">        优化数据结构：避免存储大型对象，必要时清空</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>原型链与继承：JS面向对象的精髓</li>
</ol>
<ul>
<li><p>_ <em>proto</em> _ vs prototype vs constructor的关系梳理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">（1）__proto__</span><br><span class="line">    对象的原型链指针，指向其构造函数的prototype对象，用于继承属性和方法</span><br><span class="line">（2）prototype</span><br><span class="line">    构造函数的属性，是一个对象，用于定义实例共享的属性和方法</span><br><span class="line">（3）constructor</span><br><span class="line">    prototype对象的属性，指向构造函数本身，形成闭环</span><br><span class="line">（4）关系详解</span><br><span class="line">    对象与__proto__：每个对象都有__proto__，指向构造函数的prototype，用于原型链查找，访问继承的属性和方法</span><br><span class="line">    构造函数与prototype：构造函数有一个prototype属性，指向原型对象，原型对象存储实例共享的属性和方法</span><br><span class="line">    原型对象与constructor：原型对象（prototype）有一个constructor属性，默认指向构造函数，确保实例可以通过constructor找到创建它的构造函数</span><br><span class="line">（5）关系图解</span><br><span class="line">    对象.__proto__ → 构造函数.prototype → .constructor → 构造函数</span><br><span class="line">（6）原型链</span><br><span class="line">    __proto__、prototype、constructor共同组成了原型链。当我们访问一个对象的属性时，JavaScript引擎会先在自身对象上查找，如果没有找到，则会沿着对象的指针__proto__去其原型对象上查找，如果还是没有找到，则继续沿着原型对象的__proto__指针向上查找，如此往复，直到找到原型链的顶端--Object.prototype，如果还是没有，则返回undefined。这种通过__proto__连接起来的自下而上的查找路径，就是原型链继承的核心机制</span><br><span class="line">（7）注意点</span><br><span class="line">    __proto__是非标准属性，建议使用Object.getPrototypeOf();</span><br><span class="line">    修改prototype会影响所有实例，需谨慎;</span><br><span class="line">    ES6 class简化了原型操作，但本质是一样的</span><br></pre></td></tr></table></figure>
</li>
<li><p>从原型继承到class语法糖，剖析多种继承方案的优劣</p>
</li>
</ul>
<h5 id="继承方案对比"><a href="#继承方案对比" class="headerlink" title="继承方案对比"></a>继承方案对比</h5><table>
<thead>
<tr>
<th>方案</th>
<th>实现方式</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1. 原型链继承</strong></td>
<td><code>Child.prototype = new Parent()</code></td>
<td>简单，继承原型方法</td>
<td>无法传参，子类共享父类实例属性</td>
<td>简单原型方法共享</td>
</tr>
<tr>
<td><strong>2. 借用构造函数</strong></td>
<td><code>Parent.call(this, args)</code></td>
<td>继承实例属性，可传参</td>
<td>无法继承原型方法</td>
<td>实例属性继承</td>
</tr>
<tr>
<td><strong>3. 组合继承</strong></td>
<td>组合 1+2</td>
<td>继承实例属性 + 原型方法</td>
<td>调用两次父构造函数，性能差</td>
<td>通用场景</td>
</tr>
<tr>
<td><strong>4. 寄生组合继承</strong></td>
<td><code>Object.create</code> + <code>call</code></td>
<td>继承完整，性能好</td>
<td>实现稍复杂</td>
<td>推荐方案</td>
</tr>
<tr>
<td><strong>5. ES6 class 继承</strong></td>
<td><code>class Child extends Parent</code></td>
<td>语法简洁，语义清晰</td>
<td>语法糖，本质仍原型继承</td>
<td>现代项目</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类：基础订单</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BaseOrder</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">createdAt</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">BaseOrder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getId</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">id</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案1：原型链继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">PremiumOrder</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">PremiumOrder</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">BaseOrder</span>(<span class="number">0</span>); <span class="comment">// 问题：固定 id=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> order = <span class="keyword">new</span> <span class="title class_">PremiumOrder</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(order.<span class="title function_">getId</span>()); <span class="comment">// 0（错误！）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案2：借用构造函数继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">PremiumOrder</span>(<span class="params">id, premium</span>) &#123;</span><br><span class="line">    <span class="title class_">BaseOrder</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, id); <span class="comment">// 继承实例属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">premium</span> = premium;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> order = <span class="keyword">new</span> <span class="title class_">PremiumOrder</span>(<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(order.<span class="property">id</span>, order.<span class="property">premium</span>); <span class="comment">// 1, true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(order.<span class="property">getId</span>); <span class="comment">// undefined（无原型方法）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案3：组合继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">PremiumOrder</span>(<span class="params">id, premium</span>) &#123;</span><br><span class="line">    <span class="title class_">BaseOrder</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, id); <span class="comment">// 第1次调用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">premium</span> = premium;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">PremiumOrder</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">BaseOrder</span>(); <span class="comment">// 第2次调用（无意义）</span></span><br><span class="line"><span class="title class_">PremiumOrder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">PremiumOrder</span>;</span><br><span class="line"><span class="title class_">PremiumOrder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isPremium</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">premium</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> order = <span class="keyword">new</span> <span class="title class_">PremiumOrder</span>(<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(order.<span class="title function_">getId</span>(), order.<span class="title function_">isPremium</span>()); <span class="comment">// 1, true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案4：寄生组合继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">PremiumOrder</span>(<span class="params">id, premium</span>) &#123;</span><br><span class="line">    <span class="title class_">BaseOrder</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, id); <span class="comment">// 仅调用一次</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">premium</span> = premium;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关键：用 Object.create 避免调用父构造函数</span></span><br><span class="line"><span class="title class_">PremiumOrder</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">BaseOrder</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">PremiumOrder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">PremiumOrder</span>;</span><br><span class="line"><span class="title class_">PremiumOrder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isPremium</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">premium</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> order = <span class="keyword">new</span> <span class="title class_">PremiumOrder</span>(<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(order.<span class="title function_">getId</span>(), order.<span class="title function_">isPremium</span>()); <span class="comment">// 1, true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案5：ES6 class 继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseOrder</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">createdAt</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getId</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">id</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PremiumOrder</span> <span class="keyword">extends</span> <span class="title class_ inherited__">BaseOrder</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id, premium</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(id); <span class="comment">// 必须调用</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">premium</span> = premium;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">isPremium</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">premium</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> order = <span class="keyword">new</span> <span class="title class_">PremiumOrder</span>(<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(order.<span class="title function_">getId</span>(), order.<span class="title function_">isPremium</span>()); <span class="comment">// 1, true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>异步编程终极指南：从Event Loop到Async&#x2F;Await</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）事件循环机制</span><br><span class="line">    JavaScript是一门单线程语言，事件循环机制（Event Loop）是实现异步的核心。事件循环并非JavaScript引擎的一部分，而是宿主环境（如浏览器、Node.js）提供的，它的本质是一段持续运行的进程，负责协调执行栈（或调用栈）、任务队列和微任务队列之间的工作。</span><br><span class="line">    同步任务会放入执行栈立即执行，遇到异步任务，不会阻塞进程，而是把任务交给对应的Web APIs执行，任务执行完毕之后，其回调函数不会立即执行，而是放入任务队列中，等执行栈清空之后再执行，而任务队列中又分了微任务队列（如Promise.then/.catch/.finally、queueMicroTask、MutationObserver、nextTick(Node.js)等）和宏任务队列（如setTimeOut、setInterval、DOM事件等），每一次事件循环，会等执行栈清空之后，检查微任务队列中是否有未执行的任务，如果有，则清空微任务队列，如果在微任务执行的过程中产生了新的微任务，则加到当前事件循环的微任务队列队尾，在当前事件循环中执行完毕，然后看宏任务队列中是否有未执行的任务，从中取出一个宏任务来执行，执行完毕之后，开启下一次循环。</span><br><span class="line">（2）Async/Await</span><br><span class="line">    本质：async/await是Promise的语法糖，让异步代码像同步代码一样书写，底层通过 Generator + 自动执行器 实现</span><br><span class="line">    核心原理：async函数返回Promise；await只能在async函数中使用，暂停执行等待Promise解决</span><br><span class="line">    错误处理：try/catch捕获所有await错误</span><br><span class="line">    并发控制：Promise.all并发，AbortController取消</span><br></pre></td></tr></table></figure>
</li>
<li><p>内存管理与垃圾回收（GC）：写出高性能的JS代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">5. 函数式编程（FC）与设计模式：提升代码的抽象与复用能力</span><br></pre></td></tr></table></figure></li>
</ol>
<pre><code>
## 二、TypeScript &amp; ModernCSS：类型与样式
1. TypeScript深度掌握：从入门到工程实践
- 为何选择TS：类型系统的重要性，静态检查带来的工程化优势
- 核心类型系统精讲：泛型、接口、类型别名、高级类型（联合、交叉、条件、映射类型）
- 工程实践与高级技巧：tsconfig.json深度解析、类型体操入门（infer）、结合框架（React/Vue）的最佳实践、编写高质量.d.ts声明文件

2. 现代CSS解决方案与工程化
- 布局：Flex vs Grid终极对比与应用场景
- CSS工程化架构：CSS-in-JS（styled-components）vs 原子化CSS（Tailwind CSS）的思想碰撞与选型
- CSS前言特性：变量（Custom Properties）、容器查询（@container）、:has()选择器等
- 性能优化：理解图层（layer）、善用will-change、contain提升渲染性能

## 三、现代框架深度应用与原理剖析
1. 组件化设计哲学与最佳实践
- 高内聚、低耦合的组件设计原则
- 从HOCs、Render Props到Hooks：React组件逻辑复用模式的演进
- 如何设计一个好的组件：API设计、状态管理、可测试性

2. 状态管理：大型应用的数据流转
- 为什么需要状态管理：多组件通信、状态共享、可预测性
- Redux vs Vuex vs Pinia vs Zustand：核心思想（单项数据量、Immutability）与选型考量
- 全局状态 vs 组件局部状态 vs 服务器缓存状态的最佳实践

3. 框架核心原理剖（React为例）
- Virtual DOM的本质与Diff算法的奥秘（同层比较、key的作用）
- Fiber架构：如何实现异步可中断的更新，解决长任务阻塞问题
- Hooks实现原理：useState与useEffect是如何关联到组件实例的

4. 跨框架四维：万变不离其宗
- 响应式原理对比：Vue（Proxy）vs React（setState）vs Svelte（Compiler）
- 编译时 vs 运行时：不同框架在性能与灵活性上的权衡

## 四、前端工程化体系：效率与质量的基石
1. 构建工具的演进与选择
- Webpack的核心概念：Loader、Plugin机制与构建流程
- Webpack高级性能优化：代码分割、Tree Shaking、持久化缓存、打包分析
- Vite的革命：基于ESM的Dev Server如何实现”秒级”冷启动
- Webpack vs Vite vs Turbopack：技术选型与未来趋势

2. 代码质量与团队规范
- Eslint + Prettier + Stylelint：打造团队统一的代码规范
- Git Hooks（Husky）+ lint-staged：在提交前强制校验，保证入库代码质量
- Commitizen + Conventional Commits：规范化提交信息，自动化生成Changelog

3. 自动化部署与CI/CD
- 前端应用的部署流程：从手动FTP到自动化脚本
- 理解CI/CD：持续集成、持续交付、持续部署
- 实战：使用GitHub Actions/Gitlab CI自动化测试、构建和部署

4. Monorepo：大型项目代码管理模式
- 为什么需要Monorepo：代码复用、依赖管理、统一构建
- Lerna / pnpm / Nx Workspace 等工具的对比与实践

## 五、前端性能优化：追求极致用户体验
1. 性能指标与度量
- 核心Web指标（Core Web Vitals）：LCP、FID、CLS的含义与优化方向
- 使用LightHouse、WebPageTest、Chrome DevTools Performance面板进行性能分析

2. 全链路性能优化策略
- 加载阶段
   - 资源优化：图片优化（格式、压缩、懒加载）、字体优化
   - 传输优化：HTTP/2、HTTP/3、CDN、Gzip
   - 代码优化：Code Spliting、Tree Shaking、Preload/Prefetch
- 渲染阶段
   - 关键渲染路径（CRP）优化：减少阻塞渲染的CSS/JS
   - 避免重排（Reflow）与重绘（Repaint）
   - CSS硬件加速（GPU Composition）
- 运行时阶段
   - JS执行效率：避免长任务，合理使用Web Workers
   - 事件循环与任务调度：requestAnimationFrame vs setTimeOut

3. 服务端渲染（SSR）与静态站点生成（SSG）
- 对比CSR、SSR、SSG的优劣与适用场景
- Next.js/Nuxt.js等框架在性能、SEO上的优势
- ISR、DPR等新一代渲染模式的解读

## 六、拓宽技术视野，走向更高端
1. 微前端架构：大型复杂应用的解耦方案
- 为什么需要微前端？核心价值（技术栈无关、独立部署、团队自治）与挑战
- 主流方案对比：single-spa（路由分发）、qiankun（沙箱隔离）、Garfish（字节跳动方案）的核心原理与选型考量

2. 大前端与跨端开发：一次开发，多端运行
- 跨端技术演进史：从Hybrid（Webview）到Native-like（React Native）再到自渲染（Flutter）与小程序多端（Taro/uni-app）
- Taro/uni-app等框架的核心原理（编译时转换）与实践中的“坑”

3. 全栈开发能力：打破前后端界限
- 为什么前端要学Node.js（BFF模式、SSR、提升工程化效率）
- Node.js核心：事件循环、异步I/O、Stream
- 企业级Web框架入门：NestJS（基于TypeScript的后端框架）与数据库交互（PostgreSQL + TypeORM）

## 七、AI赋能前端，迎接下一个技术范式
1. 前端工程师在AI时代的机遇与挑战
- AI将如何重塑前端开发流程（代码生成、UI设计、智能测试）
- 新的岗位需求：AI应用工程师、Prompt工程师

2. LLM应用开发核心：LangChain.js
- LangChain核心组件：Models、Prompts、Chains、Indexes、Agents
- 实战：构建一个简单的RAG（Retreival-Augmented Generation）应用

3. 构建复杂AI Agent：LangGraph.js和LangSmith.js
- LangGraph.js：当Chain不够用时，使用图来构建有状态、可循环的Agent
- LangSmith.js：调试、监控和评估你的LLM应用，确保应用效果

4. 前端智能化工具链
- GitHub Copilot/Cursor等AI编程助手的最佳实践
- Mastra等工具如何帮助前端快速搭建AI应用
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://rowe83.github.io">Rowe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://rowe83.github.io/2025/10/23/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/">https://rowe83.github.io/2025/10/23/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a></div><div class="post-share"><div class="social-share" data-image="/image/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/09/03/mcp-%E4%BB%8B%E7%BB%8D/" title="MCP介绍"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">MCP介绍</div></div><div class="info-2"><div class="info-item-1">什么是 MCP？MCP（Model Context Protocol，模型上下文协议）是一套面向“AI 客户端 ↔ 外部工具&#x2F;数据源”的开放协议与约定，用于让大语言模型在安全、可控且可审计的前提下，访问文件系统、数据库、API、知识库等外部能力。它把这些外部能力抽象为「可发现、可声明、可调用」的服务，使得不同模型与不同工具之间能够以统一的方式进行集成。  为什么需要 MCP？ 统一接入：摆脱各家“插件&#x2F;工具”形态不一致的问题，用统一规范对接任意能力。 安全可控：以最小权限、可审计日志、可声明能力的方式暴露外部资源，便于企业合规。 复用与沉淀：工具以 Server 的形式复用在不同模型&#x2F;应用中，避免重复集成成本。 可观测：调用均通过协议层，便于记录、回放与问题定位。   核心概念 Client（客户端）：承载模型推理与交互的应用（如聊天应用、IDE 扩展、Agent 框架）。 Server（服务端）：对外声明一组可用的工具、资源与提示（prompts），并实现其逻辑。 Tools（工具）：可被调用的操作（例如读取文件、发送 HTTP...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/06/27/30days-plan/" title="30天前端复习计划"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-27</div><div class="info-item-2">30天前端复习计划</div></div><div class="info-2"><div class="info-item-1">本文旨在制定一个为期一个月（4周）的前端复习计划，涵盖核心知识点、实践练习和模拟面试，实现系统性地准备前端面试。  30天前端复习计划目标 掌握前端核心知识（HTML、CSS、JavaScript、框架等） 熟悉常见面试题和技术原理 提升代码能力和项目经验表达 模拟面试场景，增强临场应变能力  前提 每天投入约 3-4小时复习（可根据实际情况调整） 每周留出时间总结和查漏补缺   第1周：基础知识巩固目标：夯实HTML、CSS、JavaScript基础，理解浏览器原理和网络基础。  Day 1：HTML &amp; CSS 基础  复习语义化标签、Flex布局、Grid布局 常见问题：BFC、浮动清除、CSS选择器优先级 练习：手写一个响应式布局页面   Day 2：JavaScript 基础  复习变量提升、闭包、this指向、原型链 常见问题：事件循环、深浅拷贝实现 练习：实现Promise、debounce&#x2F;throttle函数   Day...</div></div></div></a><a class="pagination-related" href="/2025/07/03/html-meta%E6%A0%87%E7%AD%BE/" title="html5中的meta标签"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-03</div><div class="info-item-2">html5中的meta标签</div></div><div class="info-2"><div class="info-item-1">html5中的meta标签 1. html5中的meta标签http-equiv属性有什么作用？在 HTML5 中，&lt;meta&gt; 标签的 http-equiv 属性用于提供 HTTP 头信息，允许开发者在 HTML 文档中模拟 HTTP 响应头的作用。它告诉浏览器如何处理页面或设置特定的行为。http-equiv 的值对应于 HTTP 响应头字段的名称，结合 content 属性一起使用，以指定具体的行为或参数。 主要作用http-equiv 属性通过模拟 HTTP 头字段，影响浏览器的行为或页面渲染方式。以下是常见的 http-equiv 值及其作用：  content-type指定文档的字符编码和 MIME 类型，确保浏览器正确解析页面内容。示例： 1&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;  作用：声明文档的 MIME 类型为 text/html，并指定字符编码为 UTF-8。 注意：HTML5 中推荐使用简化的...</div></div></div></a><a class="pagination-related" href="/2025/06/30/multiple-language/" title="多语言页面"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-30</div><div class="info-item-2">多语言页面</div></div><div class="info-2"><div class="info-item-1">如何实现多语言页面 在HTML中提供多语言页面需要结合内容管理、语言检测和合适的标记来确保用户能够以他们偏好的语言查看内容，同时保持SEO友好性和良好的用户体验。要实现一个多语言页面，可以从以下几个方面实现： 1. 语言检测 浏览器语言：通过HTTP请求头中的Accept-Language检测用户首选语言（如zh-CN、en-US）。 用户选择：提供语言切换器（如下拉菜单），将用户选择存储在cookie、localStorage或用户账户中。 地理位置：根据IP地址推测语言，但需谨慎使用，因准确性较低。  2....</div></div></div></a><a class="pagination-related" href="/2025/07/16/performance-paint-timing/" title="如何计算首屏和白屏时间"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-16</div><div class="info-item-2">如何计算首屏和白屏时间</div></div><div class="info-2"><div class="info-item-1">如何计算首屏和白屏时间 计算首屏时间和白屏时间是评估网页性能的重要指标，特别是在使用 HTML5 开发网站时。这些指标反映了用户感知的页面加载速度，直接影响用户体验和 SEO。以下是详细的定义、计算方法、优化建议，以及结合 HTML5 特性的实现方案。 1. 定义 白屏时间（White Screen Time）： 指从用户开始访问页面（浏览器发起请求）到页面开始显示内容（通常是 DOM 结构开始渲染）的时间。 用户看到的是“白屏”，即页面还未渲染出任何内容。 通常与解析 HTML 和加载关键 CSS 的时间相关。   首屏时间（First Screen Time）： 指从用户开始访问页面到页面首屏内容（通常是视口内可见内容）完全渲染的时间。 首屏内容可能包括文字、图片或关键组件。 涉及 HTML 解析、CSS 渲染、关键资源加载（如图片、字体）和 JavaScript 执行。    2. 计算方法计算白屏时间和首屏时间需要使用浏览器性能 API（如 HTML5 的 Performance API）或开发者工具。以下是具体方法： a....</div></div></div></a><a class="pagination-related" href="/2025/07/23/h5-signature/" title="h5电子签名"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-23</div><div class="info-item-2">h5电子签名</div></div><div class="info-2"><div class="info-item-1">h5如何实现电子签名 使用 HTML5 实现电子签名功能主要依赖 Canvas API 来捕获用户的手写签名，并结合触摸事件（touchstart、touchmove、touchend）或鼠标事件（mousedown、mousemove、mouseup）支持移动端和桌面端。签名结果可以保存为图片（如 PNG）。以下是实现方法  实现方法核心技术 Canvas API： 使用 &lt;canvas&gt; 绘制用户手写签名。 方法如 beginPath、moveTo、lineTo、stroke 实现动态描边。   触摸&#x2F;鼠标事件： 捕获用户输入（触摸或鼠标轨迹），支持移动端和桌面端。 触摸事件（touchstart 等）适配移动端。   HTML5 元素： &lt;canvas&gt;：绘制签名。 &lt;button&gt;：触发保存、清除等操作。 &lt;a&gt;：下载签名图片。   File API： 使用 canvas.toDataURL() 生成图片，Blob 保存文件。    步骤 创建 HTML 结构，包含 &lt;canvas&gt;...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Rowe</div><div class="author-info-description">罗威的森林</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Rowe83"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">前端进阶核心要点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81JavaScript%E6%B7%B1%E5%BA%A6%E8%BF%9B%E9%98%B6"><span class="toc-number"></span> <span class="toc-text">一、JavaScript深度进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94"><span class="toc-number">0.0.1.</span> <span class="toc-text">继承方案对比</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/23/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/" title="前端进阶核心要点">前端进阶核心要点</a><time datetime="2025-10-23T02:10:05.832Z" title="Created 2025-10-23 10:10:05">2025-10-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/03/mcp-%E4%BB%8B%E7%BB%8D/" title="MCP介绍">MCP介绍</a><time datetime="2025-09-03T08:59:02.556Z" title="Created 2025-09-03 16:59:02">2025-09-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/23/h5-signature/" title="h5电子签名">h5电子签名</a><time datetime="2025-07-23T09:36:20.399Z" title="Created 2025-07-23 17:36:20">2025-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/performance-paint-timing/" title="如何计算首屏和白屏时间">如何计算首屏和白屏时间</a><time datetime="2025-07-16T06:52:35.350Z" title="Created 2025-07-16 14:52:35">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/03/html-meta%E6%A0%87%E7%AD%BE/" title="html5中的meta标签">html5中的meta标签</a><time datetime="2025-07-03T06:43:45.126Z" title="Created 2025-07-03 14:43:45">2025-07-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Rowe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>